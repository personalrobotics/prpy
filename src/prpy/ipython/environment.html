<!--
Copyright (c) 2015, Carnegie Mellon University
All rights reserved.
Authors: Pras Velagapudi <pkv@cs.cmu.edu>
-->

<!-- Create main element to store the display object. -->
<div id="three-js-content"></div>

<!-- Implement actual code to render the environment. -->
<script type="text/javascript">

// Load necessary imports.
require.config({
    paths: {
        THREE: "https://cdnjs.cloudflare.com/ajax/libs/three.js/r72/three.min",
        Detector: "http://threejs.org/examples/js/Detector",
        OrbitControls: "http://threejs.org/examples/js/controls/OrbitControls"
    },
    shim: {
        THREE: { exports: "THREE" },
        Detector: { exports: "Detector" },
        OrbitControls: {
            deps: ["THREE"],
            exports: "OrbitControls"
        }
    }
});

require(["THREE", "Detector", "OrbitControls"], function(THREE, Detector, OrbitControls) {
    "use strict";

    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    // Helper function to decode Base64 strings into binary ArrayBuffers.
    function base64ToArrayBuffer(base64)
    {
        var bufferLength = base64.length * 0.75,
        len = base64.length, i, p = 0,
        encoded1, encoded2, encoded3, encoded4;

        if (base64[base64.length - 1] === "=") {
            bufferLength--;
            if (base64[base64.length - 2] === "=") {
                bufferLength--;
            }
        }

        var arraybuffer = new ArrayBuffer(bufferLength),
        bytes = new Uint8Array(arraybuffer);

        for (i = 0; i < len; i+=4) {
            encoded1 = chars.indexOf(base64[i]);
            encoded2 = chars.indexOf(base64[i+1]);
            encoded3 = chars.indexOf(base64[i+2]);
            encoded4 = chars.indexOf(base64[i+3]);

            bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
            bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
            bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
        }

        return arraybuffer;
    }

    // Check for WebGL compatibility.
    if (!Detector.webgl)
        Detector.addGetWebGLMessage();

    // Global variables for rendering.
    var container, scene, camera, renderer, controls;

    // Create Three.js scene to render environment.
    function init() 
    {
        console.log("Initialized scene.")

        // SCENE
        scene = new THREE.Scene();

        // CONTAINER
        container = document.getElementById("three-js-content");

        // CAMERA
        var VIEW_ANGLE = 45,
            ASPECT = 16. / 9.,
            NEAR = 0.1, FAR = 20000;
        var WIDTH = container.clientWidth,
            HEIGHT = WIDTH / ASPECT;
        camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
        scene.add(camera);
        camera.position.set(0.0, 2.0, 2.0);
        camera.up.set(0.0, 0.0, 1.0);
        camera.lookAt(scene.position);  

        // RENDERER
        renderer = new THREE.WebGLRenderer({ antialias:true });
        renderer.setSize(WIDTH, HEIGHT);
        container.appendChild(renderer.domElement);

        // CONTROLS
        controls = new THREE.OrbitControls(camera, renderer.domElement);

        // WINDOW RESIZE
        function onWindowResize(event)
        {
            var width = container.clientWidth;
            var height = container.clientWidth / ASPECT;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        }
        window.addEventListener("resize", onWindowResize, false);

        // LIGHT
        var light = new THREE.PointLight(0xffffff);
        light.position.set(1.0, 1.0, 2.0);
        scene.add(light);

        var ambient = new THREE.AmbientLight(0x808080);
        scene.add(ambient);

        var models = {}
        {% for model in models -%}
        // MODEL "{{ model.name }}"
        {
            // Add all materials used in the model.
            var materials = []
            {% for material in model.materials -%}
            {
                var material = new THREE.MeshLambertMaterial({
                    {% if material.properties.emissive -%}
                    emissive: new THREE.Color({{ material.properties.emissive | join(", ") }}),
                    {% endif -%}
                    {% if material.properties.diffuse -%}
                    color: new THREE.Color({{ material.properties.diffuse[:3] | join(", ") }}),
                    {%- endif %}
                    name: "{{ material.properties.name }}"
                });
                materials.push(material);
            }
            {% endfor -%}

            // Add all meshes used in the model.
            var meshes = {}
            {% for name, mesh in model.meshes.iteritems() -%}
            {
                var geometry = new THREE.BufferGeometry();

                var b64vertices = "{{ mesh.vertices }}";
                var vertices = new Float32Array(base64ToArrayBuffer(b64vertices));
                geometry.addAttribute("position", new THREE.BufferAttribute(vertices, 3));

                var b64normals = "{{ mesh.normals }}";
                var normals = new Float32Array(base64ToArrayBuffer(b64normals));
                geometry.addAttribute("normal", new THREE.BufferAttribute(normals, 3));

                var b64indices = "{{ mesh.indices }}";
                var indices = new Uint32Array(base64ToArrayBuffer(b64indices));
                geometry.setIndex(new THREE.BufferAttribute(indices, 1));

                meshes["{{ name }}"] = new THREE.Mesh(geometry, materials[{{ mesh.materialindex }}]);
            }
            {% endfor -%}

            // Assemble flattened scenegraph from the meshes.
            var model = new THREE.Object3D();
            {% for entity in model.entities -%}
            if ("{{ entity.name }}" in meshes) {
                var transform = new THREE.Matrix4();
                transform.set({{ entity.transform | join(", ") }});

                var node = meshes["{{ entity.name }}"].clone();
                node.applyMatrix(transform);
                model.add(node);
            }
            {% endfor -%}
            models["{{ model.name }}"] = model
        }
        {% endfor %}

        {% for body in bodies -%}
        {% for link in body.links -%}
        // LINK "{{ body.name }} - {{ link.name }}"
        {
            var link = new THREE.Object3D();
            link.name = "{{ body.name }} - {{ link.name }}";
            link.position.set({{ link.position | join(", ") }});
            link.quaternion.set({{ link.quaternion | join(", ") }});

            {% for geom in link.geometries -%}
            // GEOMETRY
            {
                // MATERIAL
                var material = new THREE.MeshLambertMaterial({
                    color: new THREE.Color({{ geom.color.diffuse | join(", ") }}),
                    opacity: {{ geom.color.opacity }},
                    transparent: {% if geom.color.isTransparent %}true{% else %}false{% endif %}
                });

                {% if not geom.render.filename -%}
                // COLLISION: {{ geom.collision.type }}
                {% if geom.collision.type == "Box" -%}
                var geometry = new THREE.BoxGeometry(
                    {{ geom.collision.extents | join(", ") }}
                );
                {% elif geom.collision.type == "Cylinder" -%}
                var geometry = new THREE.CylinderGeometry(
                    {{ geom.collision.radius }}, {{ geom.collision.radius }},
                    {{ geom.collision.height }}, 32
                );
                {% elif geom.collision.type == "None" -%}
                var geometry = new THREE.Geometry()
                {% elif geom.collision.type == "Sphere" -%}
                var geometry = new THREE.SphereGeometry(
                    {{ geom.collision.radius }}, 32, 32
                );
                {% elif geom.collision.type == "Trimesh" -%}
                var geometry = new THREE.BufferGeometry();

                var b64vertices = "{{ geom.collision.vertices }}";
                var vertices = new Float32Array(base64ToArrayBuffer(b64vertices));
                geometry.addAttribute("position", new THREE.BufferAttribute(vertices, 3));

                var b64indices = "{{ geom.collision.indices }}";
                var indices = new Uint32Array(base64ToArrayBuffer(b64indices));
                geometry.setIndex(new THREE.BufferAttribute(indices, 1));
                {%- endif -%}

                var mesh = new THREE.Mesh(geometry, material);
                mesh.position.set({{ geom.position | join(", ") }});
                mesh.quaternion.set({{ geom.quaternion | join(", ") }});

                link.add(mesh);
                {%- else -%}
                // RENDER
                if ("{{ geom.render.filename }}" in models) {
                    var mesh = models["{{ geom.render.filename }}"].clone()
                    mesh.scale.set({{ geom.render.scale | join(", ") }})

                    {% if not geom.color.isDefault -%}
                    mesh.traverse(function (child) {
                        if (child instanceof THREE.Mesh)
                            child.material = material;
                    });
                    {%- endif -%}

                    link.add(mesh);
                }
                {%- endif %}
            }
            {% endfor %}
            scene.add(link);
        }
        {% endfor %}
        {% endfor %}
    }

    // Perform update and schedule next update.
    function animate()
    {
        requestAnimationFrame(animate);
        render();       
        update();
    }

    // Process events in scene.
    function update()
    {
        controls.update();
    }

    // Render current version of scene.
    function render() 
    {
        renderer.render(scene, camera);
    }

    // Startup and run rendering loop.
    init();
    animate();
});
</script>
